# Deploy 1Password SCIM Bridge on Kubernetes

*Learn how to deploy 1Password SCIM Bridge using Kubernetes and load balancer services.*

#### Table of contents

- [Before you begin](#before-you-begin)
- [Step 1: Choose a deployment option](#step-1-choose-a-deployment-option)
- [Step 2: Deploy 1Password SCIM Bridge to the Kubernetes cluster](#step-2-deploy-1password-scim-bridge-to-the-kubernetes-cluster)
- [Step 3: Create a DNS record](#step-3-create-a-dns-record)
- [Step 4: Configure Let's Encrypt](#step-4-configure-lets-encrypt)
- [Step 5: Test the SCIM bridge](#step-5-test-the-scim-bridge)
- [Update your SCIM Bridge](#update-your-scim-bridge)
- [Appendix: Resource recommendations](#appendix-resource-recommendations)
- [Appendix: Customize your deployment](#appendix-customize-your-deployment)

> **Note**
>
> If you use Azure Kubernetes Service, learn how to [deploy the SCIM bridge there](https://support.1password.com/scim-deploy-azure/).

## Before you begin

Before you begin, read the [PREPARATION.md](/PREPARATION.md) document.

### Deployment structure overview

- [`op-scim-deployment.yaml`](./op-scim-deployment.yaml): The deployment object for the SCIM bridge container.
- [`op-scim-service.yaml`](./op-scim-service.yaml): Public load balancer for SCIM bridge to connect with your identity provider.
- [`op-scim-config.yaml`](./op-scim-config.yaml): Configuration for the SCIM bridge deployment.
- [`redis-deployment.yaml`](./redis-deployment.yaml): A Redis cache deployed in the cluster.
- [`redis-service.yaml`](./op-scim-service.yaml): Kubernetes Service for the Redis cache to enable connectivity inside the cluster.
- [`redis-config.yaml`](./redis-config.yaml): Configuration for the Redis cache.

## Step 1: Create the `scimsession` Kubernetes Secret

After [prepared your 1Password account](/PREPARATION.md#prepare-your-1password-account), [create a Kubernetes Secret](https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-kubectl/#create-a-secret) containing the contents of the `scimsession` credentials file. Use `--from-file=[key=]source` when you create the Secret, name it `scimsession`, specify the `scimsession` key, and set its value as the contents of the `scimsession` file. For example (replace `./scimsession` if the file is saved in another directory and/or with a different filename):

```bash
kubectl create secret generic scimsession --from-file=scimsession=./scimsession
```

### If you use Google Workspace as your identity provider

<details>
<summary>Learn how to set up 1Password SCIM Bridge for Google Workspace</summary>

1. Follow the steps to [create a Google service account, key, and API client](https://support.1password.com/scim-google-workspace/#step-1-create-a-google-service-account-key-and-api-client).
2. Using the credential file you just downloaded, create a Kubernetes Secret and substitute `<keyfile>` with the filename generated by Google for your Google Service Account:
	```bash
	kubectl create secret generic workspace-credentials --from-file=workspace-credentials.json=/path/to/<keyfile>.json
	```
3. Edit the file located at `scim-examples/beta/workspace-settings.json` and fill in correct values for:
	* **Actor**: the email address of the administrator in Google Workspace that the service account is acting on behalf of.
	* **Bridge Address**: the URL you will use for your SCIM bridge (not your 1Password account sign-in address). This is most often a subdomain of your choosing on a domain you own. For example: https://scim.example.com.
4. After you've edited the file, save it and run the following command to create a Kubernetes Secret from the settings file:
	```bash
	kubectl create secret generic workspace-settings --from-file=workspace-settings.json=../beta/workspace-settings.json
	```

</details>

## Step 2: Deploy 1Password SCIM Bridge to the Kubernetes cluster

Run the following command deploy 1Password SCIM Bridge:

```bash
kubectl apply -f .
```

If you use Google Workspace customer and have stored your `workspace-credentials.json` and `workspace-settings.json` files in the same directory as your deployment files, you may see the following error after running `kubectl apply -f .`:

```bash
error validating "workspace-credentials.json": error validating data: [apiVersion not set, kind not set]; if you choose to ignore these errors, turn validation off with --validate=false
error validating "workspace-settings.json": error validating data: [apiVersion not set, kind not set]; if you choose to ignore these errors, turn validation off with --validate=false
```
You can safely ignore these errors, or move the `workspace-credentials.json` and `workspace-settings.json` to a different directory before running `kubectl apply -f .`.

## Step 3: Create a DNS record

The [`op-scim-bridge` Service](./op-scim-service.yaml) creates a public load balancer attached to your cluster, which forwards TLS traffic to SCIM bridge.

Run the following command:

```bash
kubectl get svc
```

Copy the address listed under the `External IP` column for the `op-scim-bridge` Service from the output.

> **Note:**
>
> It can take a few minutes before the public address becomes available. Run the command again if doesn't appear in the output.

After you copy the address, create a public DNS record pointing to this address, as outlined in [the preparation guide](/PREPARATION.md).

## Step 4: Configure Let's Encrypt

After you've created a DNS record and it's propagated, run the following command to set the `OP_TLS_DOMAIN` environment variable to the fully-qualified domain name (FQDN) for the SCIM bridge based on this record. Replace `scim.example.com` with the FQDN.

```bash
kubectl set env deploy/op-scim-bridge OP_TLS_DOMAIN=scim.example.com
```

The SCIM bridge will restart and acquire a TLS certificate using Let's Encrypt.

## Step 5: Test the SCIM bridge

You can test your instance by requesting `https://[your-domain]/scim/Users`, with the header `Authorization: Bearer [bearer token]`, which should return a list of the users in your 1Password account.

For example, to do this with `curl`:

```bash
curl --header "Authorization: Bearer TOKEN_GOES_HERE" https://<domain>/scim/Users
```

After the bridge tests successfully, you can [connect your identity provider](https://support.1password.com/scim/#step-3-connect-your-identity-provider).

## Update your SCIM bridge

üëç Check for 1Password SCIM Bridge updates on the [SCIM bridge release page](https://app-updates.agilebits.com/product_history/SCIM).

To update SCIM bridge, connect to your Kubernetes cluster and run the following command, replacing v2.8.0 with the latest version:

```bash
kubectl set image deploy/op-scim-bridge op-scim-bridge=1password/scim:v2.8.1
```

The update should take 2-3 minutes for Kubernetes to complete.

## [ DO WE NEED THE NEXT TWO H3S? ]

### October 2020 Upgrade Changes

As of October 2020, the `scim-examples` Kubernetes deployment now uses `op-scim-config.yaml` to set the configuration needed for your SCIM bridge, and has changed the deployment names from `op-scim` to `op-scim-bridge`, and `redis` to `op-scim-redis` for clarity and consistency.

You‚Äôll need to re-configure your options in `op-scim-config.yaml`, particularly `OP_TLS_DOMAIN`. You may also want to delete your previous `op-scim` and `redis` deployments to prevent conflict between the two versions.

```bash
kubectl delete deployment/op-scim deployment/redis
kubectl apply -f .
```

You‚Äôll then need to update your SCIM bridge‚Äôs domain name DNS record. You can find the IP for that with:

```bash
kubectl describe service/op-scim-bridge
# look for ‚ÄòLoadBalancer Ingress‚Äô
```

This is a one-time operation to change the deployment and service names of the SCIM bridge so they are more easily identifiable to administrators.

### April 2021 Upgrade Changes (SCIM bridge 2.0)

With the release of SCIM bridge 2.0, the environment variables `OP_REDIS_HOST` and `OP_REDIS_PORT` have been deprecated and in favour of `OP_REDIS_URL`. Ensure that your `op-scim-config.yaml` file has changed to reflect this new environment variable, and reapplied to your pods with:

```bash
cd scim-examples/kubernetes
git pull
kubectl delete configmaps op-scim-configmap
kubectl apply -f .
kubectl scale deploy op-scim-bridge --replicas=0 && sleep 3 && kubectl scale deploy op-scim-bridge --replicas=1
```

## Appendix: Resource recommendations

The default resource recommendations for the SCIM bridge and Redis deployments are acceptable in most scenarios, but they may fall short in high-volume deployments where a large number of users and/or groups are being managed. We strongly recommend increasing the resources for both the SCIM bridge and Redis deployments.

| Expected Provisioned Users |  Resources |
| ------- | ------- |
| 1-1000  |  Default  |
| 1000-5000  |  High Volume Deployment  |
| 5000+  |  Very High Volume Deployment  |

Our current default resource requirements (defined in [op-scim-deployment](https://github.com/1Password/scim-examples/blob/master/kubernetes/op-scim-deployment.yaml#L29) and [redis-deployment.yaml](https://github.com/1Password/scim-examples/blob/master/kubernetes/redis-deployment.yaml#L21)) are:

<details>
  <summary>Default</summary>

  ```yaml
  requests:
    cpu: 125m
    memory: 256M

  limits:
    cpu: 250m
    memory: 512M
  ```
</details>

Note that these are the recommended `requests` and `limits` values for both the SCIM bridge and Redis containers. These values can be scaled down again to the default values after the initial large provisioning event.

<details>
  <summary>High Volume Deployment</summary>

  ```yaml
  requests:
    cpu: 500m
    memory: 512M

  limits:
    cpu: 1000m
    memory: 1024M
  ```
</details>  

<details>
  <summary>Very High Volume Deployment</summary>

  ```yaml
  requests:
    cpu: 1000m
    memory: 1024M

  limits:
    cpu: 2000m
    memory: 2048M
  ```
</details> 

Configuring these values can be done with Kubernetes commands. You can get the names of the deployments with `kubectl get deployments`.

```bash
# scale down deployment
kubectl scale --replicas=0 deployment/op-scim-bridge

# scale down redis deployment
kubectl scale --replicas=0 deployment/op-scim-bridge-redis-master

# update op-scim-redis resources
kubectl set resources deployment op-scim-bridge-redis-master -c=redis --requests=cpu=250m,memory=512M --limits=cpu=500m,memory=1024M

# update op-scim-bridge resources
kubectl set resources deployment op-scim-bridge -c=op-scim-bridge --requests=cpu=500m,memory=512M --limits=cpu=1000m,memory=1024M

# scale up deployment
kubectl scale --replicas=1 deployment/op-scim-bridge-redis-master

# scale up deployment
kubectl scale --replicas=1 deployment/op-scim-bridge
```

Please reach out to our [support team](https://support.1password.com/contact/) if you need help with the configuration or to tweak the values for your deployment.

## Appendix: Customize your deployment

You can customize your 1Password SCIM Bridge deployment using some of the methods below.

### Self-managed TLS

There are two ways to use a self-managed TLS certificate, which disables Let's Encrypt functionality.

#### Load balancer

You can terminate TLS traffic on a public-facing load balancer or reverse proxy, then redirect HTTP traffic to SCIM bridge within your private network. Skip the step to configure Let's Encrypt, or revert to the default state by setting `OP_TLS_DOMAIN` to `""`:

```bash
kubectl set env deploy/op-scim-bridge OP_TLS_DOMAIN=""
```

Modify [`op-scim-service.yaml`](./op-scim-service.yaml) to use the alternate `http` port for the Service as noted within the manifest. Traffic from your TLS endpoint should be directed to this port (80, by default). If SCIM bridge has already been deployed, apply the amended Service manifest:

```bash
kubectl apply -f ./op-scim-service.yaml
```

In this configuration, 1Password SCIM Bridge will listen for unencrypted traffic on the `http` port of the Pod.

#### Manually-provided key/certificate

Alternatively, you can create a TLS Secret containing your key and certificate files, which can then be used by your SCIM bridge. This will also disable Let's Encrypt functionality.

Assuming these files exist in the working directory, create the Secret and set the `OP_TLS_CERT_FILE` and `OP_TLS_KEY_FILE` variables to redeploy SCIM bridge using your certificate:

```bash
kubectl create secret tls op-scim-tls --cert=./certificate.pem --key=./key.pem
kubectl set env deploy op-scim-bridge \
  OP_TLS_CERT_FILE="/secrets/tls.crt" \
  OP_TLS_KEY_FILE="/secrets/tls.key"
```

> **Note**
>
> If your certificate and key files are located elsewhere or have different names, replace `./certificate.pem` and `./key.pem` with the paths to these files, i.e.:
>
> ```sh
> kubectl create secret tls op-scim-tls --cert=path/to/cert/file --key=path/to/key/file
> ```

### External Redis

If you prefer to use an existing Redis cache, omit the the `redis-*.yaml` files when deploying to your Kubernetes cluster. If you've already deployed the SCIM bridge, you can delete the objects associated with Redis:

```bash
kubectl delete \
  -f redis-config.yaml \
  -f redis-deployment.yaml \
  -f redis-service.yaml
```

Edit the value of the `OP_REDIS_URL` environment variable in [`op-scim-config.yaml`](./op-scim-config.yaml).¬†Or set it directly if you have already deployed the bridge:

```bash
kubectl set env deploy/op-scim-bridge OP_REDIS_URL="redis[s]://server:port"
```

### Human-readable logs

Set `OP_PRETTY_LOGS` to `1` if you'd like the SCIM bridge to output logs in a human-readable format:

```bash
kubectl set env deploy/op-scim-bridge OP_PRETTY_LOGS=1
```

This may be helpful if you aren't planning on doing custom log ingestion in your environment.

### Debug mode

Set `OP_DEBUG` to `1` to enable debug output in the logs:

```bash
kubectl set env deploy/op-scim-bridge OP_DEBUG=1
```

This may be useful for troubleshooting, or when contacting 1Password Support.

### TRACE mode

Set `OP_TRACE` to `1` to enable TRACE-level debug output in the logs:

```bash
kubectl set env deploy/op-scim-bridge OP_TRACE=1
```

This may be useful for troubleshooting Let‚Äôs Encrypt integration issues.

### Health check ping server

On some Kubernetes clusters, health checks can fail for the SCIM bridge before the bridge is able to obtain a Let‚Äôs Encrypt certificate. Set `OP_PING_SERVER` to `1` to enable a `/ping` endpoint on port `80` so that health checks will always be brought online:

```bash
kubectl set env deploy/op-scim-bridge OP_PING_SERVER=1
```

No other endpoints (such as `/scim`) are exposed through this port.
